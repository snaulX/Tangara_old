#include <cstdlib>
#include "EntryRule.hpp"
#include "EntryBuilder.hpp"
#include "ClassBuilder.hpp"
#include "StructBuilder.hpp"
#include "EnumBuilder.hpp"
#include "NativeMethodImpl.hpp"
#include "NativeCtorImpl.hpp"
#include "TgRef.hpp"
#include "TgValue.hpp"

using namespace Tangara;

namespace EnigmaLabs {
    enum class AuthResult {
        OK,
        Failed
    };

    class Auth {
    public:
        Auth() {
            _password = "mypassword1234";
        }

        AuthResult Authenticate(char* password) {
            if (strcmp(_password, password) == 0) {
                return AuthResult::OK;
            } else {
                return AuthResult::Failed;
            }
        }

    private:
        const char* _password;

    // Must be generated by Tangara
    public:
        static const uint _tangara_type = 3361783409;
    };
}

tgObject* EnigmaLabs_Auth_Authenticate(tgObject *obj, size_t params_size, tgObject *params, void *custom_obj) {
    tgObject password_param = params[0];
    char* password_param_data = (char*)malloc(password_param.data_size);
    memcpy_s(password_param_data, password_param.data_size, password_param.data, password_param.data_size);
    EnigmaLabs::Auth *cpp_obj = (EnigmaLabs::Auth*)obj->data;
    EnigmaLabs::AuthResult result = cpp_obj->Authenticate(password_param_data);
    tgObject *to_return = (tgObject*) malloc(sizeof(tgObject));
    to_return->type = nullptr; // TODO: add type
    to_return->data_size = sizeof(EnigmaLabs::AuthResult);
    EnigmaLabs::AuthResult *result_ptr = (EnigmaLabs::AuthResult*)malloc(to_return->data_size);
    *result_ptr = result;
    to_return->data = result_ptr;
    return to_return;
}

tgObject* EnigmaLabs_Auth_ctor0(size_t params_size, tgObject *params, void *custom_obj) {
    tgObject *to_return = (tgObject*) malloc(sizeof(tgObject));
    to_return->type = nullptr; // TODO: add type
    to_return->data_size = sizeof(EnigmaLabs::AuthResult);
    EnigmaLabs::Auth *result_ptr = new EnigmaLabs::Auth();
    to_return->data = result_ptr;
    return to_return;
}

int main()
{
    auto rule = EntryRule();
    rule.Namespace("EnigmaLabs");
    rule.TypeAccess(AccessModifier_Private);
    auto eb = EntryBuilder("EnigmaLabs", &rule);
    eb.CreateEnum("AuthResult")
        .Literal("OK")
        .Literal("Failed")
        .Build();
    auto auth_class = eb.CreateClass("Auth")
        .SetAccess(AccessModifier_Public)
        .CreateField("_password", TgRef("CString"))
            .SetAccess(AccessModifier_Private)
            .Build()
        .CreateMethod("Authenticate")
            .Return(TgRef("AuthResult"))
            .Params()
                .Param("password", TgRef("CString"))
                .Build()
            .Implementation(NativeMethodImpl(&EnigmaLabs_Auth_Authenticate))
            .Build()
        .CreateConstructor()
            .Params().Build()
            .Implementation(NativeCtorImpl(&EnigmaLabs_Auth_ctor0))
            .Build()
        //.CreateProperty("MyProp", TgRef("PropType")).Build()
        .Build();
    tgObject *auth_obj = auth_class.ctors[0].ctorptr(0, nullptr, nullptr);
    auth_class.methods[0].methodptr(auth_obj, 1, tgConvertValToObj(TgValue::CStr("password")), nullptr);
    auto eerule = EntryRule(&rule);
    eerule.UsingNamespace("Enigma.Engine");
    //eerule.Enable();
    eb.CreateClass("MyEntity")
        .Inherits(TgRef("Entity"))
        .CreateProperty("ReloadTime", TgRef("int"))
            .SetKind(MethodKind_Static)
            //.SetAttribute(TgRef("ConsoleVar"), TgArgs(TgValue::CStr("reload_time")))
            .Build()
        .Build();
    //eerule.Disable();
    eerule.Free();
    tgEntry el = eb.Build();

    printf("\nEntry name %s\n", el.name);
    for (int i = 0; i < el.types_size; ++i) {
        tgType t = el.types[i];
        printf("Type %s of kind %d and access %d hash %u\n", t.name, t.kind, t.access, t.hash);
        printf("Fields:\n");
        for (int j = 0; j < t.fields_size; ++j) {
            tgField f = t.fields[j];
            printf("%s %s with access %d and kind %d\n", (char*)f.type.ref_data,//tgResolveTypeRef(&f.type, &el)->name,
                   f.name, f.access, f.kind);
        }
        printf("Properties:\n");
        for (int j = 0; j < t.props_size; ++j) {
            tgProp p = t.props[j];
            printf("%s %s with kind %d\n", (char*)p.type.ref_data,//tgResolveTypeRef(&p.type, &el)->name,
                   p.name, p.kind);
        }
        printf("\n");
    }

    /* output:

    Param value: "default value"

    Entry name EnigmaLabs
    Type EnigmaLabs.MyEntity of kind 0 and access 0
    Fields:
    int _propField_ReloadTime with access 0 and kind 0
    Properties:
    int ReloadTime with kind 1

    Type EnigmaLabs.MyClass of kind 0 and access 1
    Fields:
    FieldType fieldName with access 3 and kind 0
    PropType _propField_MyProp with access 0 and kind 0
    Properties:
    PropType MyProp with kind 0

     */
}
